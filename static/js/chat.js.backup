/**
 * WebSocket-based Chat Application
 * 
 * This module handles real-time chat functionality including:
 * - WebSocket connection management
 * - Message sending/receiving
 * - Online users list
 * - Typing indicators
 * - Connection status
 */

console.log('[CHAT] chat.js loaded');

// ============================================
// Configuration and Constants
// ============================================

const MAX_RECONNECT_ATTEMPTS = 5;
const RECONNECT_INTERVAL = 3000; // 3 seconds
const TYPING_TIMEOUT = 2000; // 2 seconds
// Use the main chat room by default
const CHAT_ROOM = 'main';

// Get and validate the authentication token
const AUTH_TOKEN = (() => {
    const token = window.ACCESS_TOKEN || getTokenFromStorage();
    
    if (!token) {
        console.error('‚ùå No authentication token found');
        return null;
    }
    
    // Log token info (without exposing the full token)
    const tokenParts = token.split('.');
    if (tokenParts.length === 3) {
        try {
            const payload = JSON.parse(atob(tokenParts[1]));
            console.log('üîë Token details:', {
                subject: payload.sub,
                expires: payload.exp ? new Date(payload.exp * 1000).toISOString() : 'No expiration',
                issued: payload.iat ? new Date(payload.iat * 1000).toISOString() : 'No issue time',
                tokenStart: token.substring(0, 10) + '...',
                tokenEnd: '...' + token.substring(token.length - 10)
            });
        } catch (e) {
            console.warn('‚ö†Ô∏è Could not parse token payload:', e);
        }
    } else {
        console.warn('‚ö†Ô∏è Token format appears to be invalid');
    }
    
    return token;
})();

// Construct WebSocket URL
const WS_BASE_URL = window.WEBSOCKET_URL || `ws://${window.location.host}/ws/chat`;

// Function to get WebSocket URL with proper parameters
function getWebSocketUrl() {
    const url = new URL(WS_BASE_URL);
    
    // Add room ID to the path
    url.pathname = url.pathname.replace(/\/$/, '') + `/${CHAT_ROOM}`;
    
    // Add token as query parameter
    const params = new URLSearchParams();
    if (AUTH_TOKEN) {
        params.set('token', AUTH_TOKEN);
    }
    
    // Add timestamp to prevent caching
    params.set('_t', Date.now());
    
    // Construct the final URL
    const finalUrl = `${url.toString()}?${params.toString()}`;
    console.log('üåê WebSocket URL:', finalUrl);
    return finalUrl;
}

const WS_URL = getWebSocketUrl();

// ============================================
// State Management
// ============================================

let socket = null;
let reconnectAttempts = 0;
const typingUsers = new Set();
let typingTimer = null;
let currentRoom = CHAT_ROOM;
let pingInterval = null;
let lastPongTime = null;
const PING_INTERVAL = 30000; // 30 seconds
const PONG_TIMEOUT = 10000;  // 10 seconds

// Get user data from the template or create a guest user
const currentUser = window.currentUser || {
    id: `guest-${Math.random().toString(36).substr(2, 9)}`,
    username: 'Guest',
    email: ''
};

// Add room info to user object
currentUser.room = currentRoom;

// ============================================
// DOM Elements
// ============================================

const elements = {
    messageInput: document.getElementById('message-input'),
    sendButton: document.getElementById('send-button'),
    chatMessages: document.getElementById('chat-messages'),
    onlineUsersList: document.getElementById('online-users'),
    typingIndicator: document.getElementById('typing-indicator'),
    connectionStatus: document.getElementById('connection-status'),
    onlineCount: document.getElementById('online-count'),
    toggleSidebarBtn: document.getElementById('toggle-sidebar'),
    chatSidebar: document.getElementById('chat-sidebar'),
    messageForm: document.getElementById('message-form')
};

// ============================================
// Utility Functions
// ============================================

function getTokenFromStorage() {
    // Check cookies
    const cookies = document.cookie.split(';')
        .map(c => c.trim().split('='))
        .find(([name]) => name === 'access_token');
    
    if (cookies?.[1]) return cookies[1];
    
    // Check localStorage
    try {
        return localStorage.getItem('access_token');
    } catch (e) {
        console.warn('localStorage not available:', e);
        return null;
    }
}

function escapeHtml(unsafe) {
    return unsafe
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#039;');
}

function formatTime(date) {
    if (!(date instanceof Date)) date = new Date(date);
    return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
}

function getUserColor(userId) {
    if (!userId) return '#6c757d';
    let hash = 0;
    for (let i = 0; i < userId.length; i++) {
        hash = userId.charCodeAt(i) + ((hash << 5) - hash);
    }
    return `hsl(${Math.abs(hash % 360)}, 70%, 60%)`;
}

// ============================================
// WebSocket Connection
// ============================================

// Helper function to get WebSocket state name
function getWebSocketState(state) {
    const states = {
        0: 'CONNECTING',
        1: 'OPEN',
        2: 'CLOSING',
        3: 'CLOSED'
    };
    return states[state] || `UNKNOWN (${state})`;
}

function initWebSocket() {
    console.log('Initializing WebSocket connection...');
    
    if (!AUTH_TOKEN) {
        const error = 'No authentication token available';
        console.error(error);
        updateConnectionStatus(false, 'Authentication required');
        return Promise.reject(new Error(error));
    }

    closeExistingConnection();
    updateConnectionStatus(false, 'Connecting to chat...');

    return new Promise((resolve, reject) => {
        try {
            console.log('Creating new WebSocket instance');
            
            // Get the WebSocket URL with all necessary parameters
            const wsUrl = getWebSocketUrl();
            console.log('Connecting to WebSocket with URL:', wsUrl);
            
            // Create WebSocket connection
            socket = new WebSocket(wsUrl);
            console.log('üîå WebSocket created successfully');
            
            // Set binary type to arraybuffer for better performance
            socket.binaryType = 'arraybuffer';
            
            // WebSocket event handlers
            socket.onopen = (event) => {
                console.log('‚úÖ WebSocket connection established', event);
                console.log('WebSocket readyState:', getWebSocketState(socket.readyState));
                console.log('WebSocket protocol:', socket.protocol);
                console.log('WebSocket extensions:', socket.extensions);
                console.log('WebSocket binaryType:', socket.binaryType);
                
                reconnectAttempts = 0;
                updateConnectionStatus(true, 'Connected');
                
                // Setup ping-pong mechanism
                const setupPingPong = () => {
                    // Clear any existing interval
                    if (pingInterval) {
                        clearInterval(pingInterval);
                    }
                    
                    // Reset pong time
                    lastPongTime = Date.now();
                    
                    // Setup ping interval
                    pingInterval = setInterval(() => {
                        if (socket && socket.readyState === WebSocket.OPEN) {
                            try {
                                const pingMsg = JSON.stringify({
                                    type: 'ping',
                                    timestamp: new Date().toISOString()
                                });
                                console.log('Sending ping:', pingMsg);
                                socket.send(pingMsg);
                                
                                // Check if we've received a pong recently
                                const timeSinceLastPong = Date.now() - lastPongTime;
                                if (timeSinceLastPong > PONG_TIMEOUT) {
                                    console.warn('No pong received in the last', PONG_TIMEOUT, 'ms');
                                    // Force reconnect if we haven't received a pong
                                    socket.close(4000, 'No pong received');
                                }
                            } catch (e) {
                                console.error('Error sending ping:', e);
                            }
                        }
                    }, PING_INTERVAL);
                };
                
                setupPingPong();
                
                // The server will send connection_established message
                console.log('Waiting for server handshake...');
                
                // Send an initial ping to test the connection
                setTimeout(() => {
                    if (socket && socket.readyState === WebSocket.OPEN) {
                        try {
                            const pingMsg = JSON.stringify({
                                type: 'ping',
                                timestamp: new Date().toISOString()
                            });
                            console.log('Sending initial ping:', pingMsg);
                            socket.send(pingMsg);
                        } catch (e) {
                            console.error('Error sending initial ping:', e);
                        }
                    }
                }, 500);
                
                resolve();
            };
            
            socket.onmessage = (event) => {
                console.log('üì® Received WebSocket message:', event.data);
                handleIncomingMessage(event);
            };
            
            socket.onclose = (event) => {
                console.log('‚ùå WebSocket closed:', {
                    code: event.code,
                    reason: event.reason,
                    wasClean: event.wasClean
                });
                updateConnectionStatus(false, 'Disconnected');
                
                // Clear ping interval
                if (pingInterval) {
                    clearInterval(pingInterval);
                    pingInterval = null;
                }
                
                // Attempt to reconnect if the connection was not closed cleanly
                if (!event.wasClean && reconnectAttempts < MAX_RECONNECT_ATTEMPTS) {
                    const delay = Math.min(1000 * Math.pow(2, reconnectAttempts), 30000);
                    console.log(`Reconnecting in ${delay}ms (attempt ${reconnectAttempts + 1}/${MAX_RECONNECT_ATTEMPTS})`);
                    
                    setTimeout(() => {
                        reconnectAttempts++;
                        initWebSocket().catch(console.error);
                    }, delay);
                }
                
                reject(new Error(`WebSocket closed: ${event.reason || 'Unknown reason'}`));
            };
            
            socket.onerror = (error) => {
                console.error('WebSocket error:', error);
                console.error('WebSocket readyState:', socket ? getWebSocketState(socket.readyState) : 'No socket');
                updateConnectionStatus(false, 'Connection error');
                reject(error);
            };
                
                // Setup ping interval
                pingInterval = setInterval(() => {
                    if (socket && socket.readyState === WebSocket.OPEN) {
                        try {
                            const pingMsg = JSON.stringify({
                                type: 'ping',
                                timestamp: new Date().toISOString()
                            });
                            console.log('Sending ping:', pingMsg);
                            socket.send(pingMsg);
                            
                            // Check if we've received a pong recently
                            const timeSinceLastPong = Date.now() - lastPongTime;
                            if (timeSinceLastPong > PONG_TIMEOUT) {
                                console.warn('No pong received in the last', PONG_TIMEOUT, 'ms');
                                // Force reconnect if we haven't received a pong
                                socket.close(4000, 'No pong received');
                            }
                        } catch (e) {
                            console.error('Error sending ping:', e);
                        }
                    }
                }, PING_INTERVAL);
            };
            
            socket.onopen = (event) => {
                console.log('‚úÖ WebSocket connection established', event);
                console.log('WebSocket readyState:', getWebSocketState(socket.readyState));
                console.log('WebSocket protocol:', socket.protocol);
                console.log('WebSocket extensions:', socket.extensions);
                console.log('WebSocket binaryType:', socket.binaryType);
                
                reconnectAttempts = 0;
                updateConnectionStatus(true, 'Connected');
                
                // Setup ping-pong mechanism
                setupPingPong();
                
                // The server will send connection_established message
                console.log('Waiting for server handshake...');
                
                // Send an initial ping to test the connection
                setTimeout(() => {
                    if (socket && socket.readyState === WebSocket.OPEN) {
                        try {
                            const pingMsg = JSON.stringify({
                                type: 'ping',
                                timestamp: new Date().toISOString()
                            });
                            console.log('Sending initial ping:', pingMsg);
                            socket.send(pingMsg);
                        } catch (e) {
                            console.error('Error sending initial ping:', e);
                        }
                    }
                }, 500);
            };

            socket.onmessage = (event) => {
                console.log('üì® Received WebSocket message:', event.data);
                handleIncomingMessage(event);
            };

            socket.onclose = (event) => {
                console.log('‚ùå WebSocket closed:', {
                    code: event.code,
                    reason: event.reason,
                    wasClean: event.wasClean
                });
                updateConnectionStatus(false, 'Disconnected');
                if (!event.wasClean) {
                    attemptReconnect();
                }
            };

            socket.onerror = (error) => {
                console.error('WebSocket error:', error);
                updateConnectionStatus(false, 'Connection error');
                reject(error);
            };
        } catch (error) {
            console.error('Error initializing WebSocket:', error);
            updateConnectionStatus(false, 'Connection failed');
            reject(error);
        }
    });
}

function closeExistingConnection() {
    if (socket) {
        try {
            socket.onclose = null;
            socket.close();
        } catch (e) {
            console.warn('Error closing connection:', e);
        } finally {
            socket = null;
        }
    }
}

function authenticateWebSocket() {
    console.group('WebSocket Authentication');
    
    if (!socket) {
        const error = 'WebSocket is not initialized';
        console.error('‚ùå', error);
        updateConnectionStatus(false, 'Connection error');
        console.groupEnd();
        return;
    }

    if (socket.readyState !== WebSocket.OPEN) {
        const error = `WebSocket is not open (state: ${socket.readyState})`;
        console.error('‚ùå', error);
        console.log('Current WebSocket state:', getWebSocketState(socket.readyState));
        console.groupEnd();
        return;
    }

    if (!AUTH_TOKEN) {
        const error = 'No authentication token available';
        console.error('‚ùå', error);
        updateConnectionStatus(false, 'Authentication required');
        console.groupEnd();
        return;
    }

    const authMessage = {
        type: 'auth',
        token: AUTH_TOKEN,
        user_id: currentUser.id,
        username: currentUser.username,
        email: currentUser.email,
        timestamp: new Date().toISOString()
    };

    console.log('üîë Sending authentication message:', { 
        ...authMessage,
        token: '***' + (AUTH_TOKEN ? 'token-present' : 'no-token') + '***'
    });

    try {
        const messageString = JSON.stringify(authMessage);
        console.log('üì§ Raw message being sent:', messageString);
        
        socket.send(messageString);
        console.log('‚úÖ Authentication message sent successfully');
        
        // Set a timeout to check if we receive a response
        setTimeout(() => {
            console.log('‚è±Ô∏è  Checking authentication status...');
            console.log('Current WebSocket state:', getWebSocketState(socket.readyState));
            console.log('Buffered amount:', socket.bufferedAmount);
            
            if (socket.readyState === WebSocket.OPEN) {
                console.log('‚úÖ WebSocket is still open, but no response received yet');
                // Try requesting online users directly
                console.log('Attempting to request online users...');
                requestOnlineUsers();
            } else {
                console.error('‚ùå WebSocket is no longer open');
            }
        }, 2000);
        
    } catch (error) {
        console.error('‚ùå Error sending authentication message:', error);
        updateConnectionStatus(false, 'Authentication failed');
    } finally {
        console.groupEnd();
    }
}

// Helper function to get WebSocket state name
function getWebSocketState(state) {
    const states = {
        0: 'CONNECTING',
        1: 'OPEN',
        2: 'CLOSING',
        3: 'CLOSED'
    };
    return states[state] || `UNKNOWN (${state})`;
}

function handleConnectionClose(event) {
    console.log('WebSocket closed:', event.code, event.reason);
    updateConnectionStatus(false, 'Disconnected');
    
    if (!event.wasClean) {
        console.log('Unexpected disconnect, attempting to reconnect...');
        attemptReconnect();
    }
}

function handleConnectionError(error) {
    console.error('WebSocket error:', error);
    updateConnectionStatus(false, 'Connection error');
}

function attemptReconnect() {
    if (reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {
        console.error('Max reconnection attempts reached');
        updateConnectionStatus(false, 'Connection lost. Please refresh.');
        return;
    }

    const delay = Math.min(RECONNECT_INTERVAL * Math.pow(2, reconnectAttempts), 30000);
    reconnectAttempts++;
    
    console.log(`Reconnecting in ${delay}ms (attempt ${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS})`);
    updateConnectionStatus(false, `Reconnecting in ${Math.ceil(delay / 1000)}s...`);
    
    setTimeout(() => initWebSocket().catch(console.error), delay);
}

// ============================================
// Message Handling
// ============================================

function handleIncomingMessage(event) {
    let message;
    try {
        message = JSON.parse(event.data);
        if (!message || !message.type) {
            throw new Error('Invalid message format');
        }
    } catch (error) {
        console.error('‚ùå Error parsing message:', error, 'Raw data:', event.data);
        return;
    }

    console.log('üì© Processing message type:', message.type, message);

    try {
        console.log('üì© Processing message type:', message.type, message);
        
        switch (message.type) {
            case 'connection_established':
                console.log('‚úÖ Connection established with server');
                console.log('Client ID:', message.client_id);
                console.log('User ID:', message.user_id);
                console.log('Room:', message.room_id);
                
                // Store the client ID for future use
                if (message.client_id) {
                    currentUser.clientId = message.client_id;
                }
                
                // Update current room if different
                if (message.room_id && message.room_id !== currentUser.room) {
                    console.log(`Switching to room: ${message.room_id}`);
                    currentUser.room = message.room_id;
                }
                
                // Request online users after successful connection
                requestOnlineUsers();
                break;
                
            case 'online_users':
                console.log('üë• Received online users:', message.users || []);
                updateOnlineUsersList(message.users || []);
                break;
                
            case 'chat_message':
                handleChatMessage(message);
                break;
                
            case 'user_joined':
                console.log('üëã User joined:', message.username);
                handleUserJoined(message);
                // Refresh online users when someone joins
                requestOnlineUsers();
                break;
                
            case 'user_left':
                console.log('üëã User left:', message.username);
                handleUserLeft(message);
                // Refresh online users when someone leaves
                requestOnlineUsers();
                break;
                
            case 'typing':
                handleTypingIndicator(message);
                break;
                
            case 'pong':
                // Handle pong response for connection testing
                console.log('üèì Pong received:', message);
                break;
                
            case 'error':
                console.error('‚ùå Server error:', message.message || 'Unknown error');
                updateConnectionStatus(false, `Error: ${message.message || 'Connection error'}`);
                break;
                
            default:
                console.warn('‚ö†Ô∏è Unknown message type:', message.type, message);
        }
    } catch (error) {
        console.error('‚ùå Error handling message:', error, 'Message:', message);
    }
}

function sendMessage(content) {
    if (!socket || socket.readyState !== WebSocket.OPEN) {
        console.warn('Cannot send message: WebSocket not connected');
        return false;
    }

    const message = {
        type: 'chat_message',
        content,
        timestamp: new Date().toISOString(),
        user_id: currentUser.id,
        username: currentUser.username
    };

    try {
        socket.send(JSON.stringify(message));
        return true;
    } catch (error) {
        console.error('Error sending message:', error);
        return false;
    }
}

function sendTypingIndicator(isTyping) {
    if (!socket || socket.readyState !== WebSocket.OPEN) return;
    
    const wasTyping = typingUsers.has(currentUser.username);
    if (isTyping === wasTyping) return;
    
    if (isTyping) {
        typingUsers.add(currentUser.username);
    } else {
        typingUsers.delete(currentUser.username);
    }
    
    socket.send(JSON.stringify({
        type: 'typing',
        is_typing: isTyping,
        user_id: currentUser.id,
        username: currentUser.username
    }));
    
    updateTypingIndicator();
}

// ============================================
// UI Updates
// ============================================

function updateConnectionStatus(connected, message = '') {
    if (!elements.connectionStatus) return;
    elements.connectionStatus.textContent = message || (connected ? 'Connected' : 'Disconnected');
    elements.connectionStatus.className = `badge rounded-pill ${connected ? 'bg-success' : 'bg-danger'}`;
}

function displayMessage({ sender, content, messageType = 'chat_message', timestamp }) {
    if (!elements.chatMessages) return;
    
    const messageDiv = document.createElement('div');
    messageDiv.className = `message ${messageType}`;
    
    messageDiv.innerHTML = `
        <div class="message-header">
            <span class="message-sender">${escapeHtml(sender)}</span>
            <span class="message-time">${formatTime(timestamp || new Date())}</span>
        </div>
        <div class="message-content">${escapeHtml(content)}</div>
    `;
    
    elements.chatMessages.appendChild(messageDiv);
    elements.chatMessages.scrollTop = elements.chatMessages.scrollHeight;
}

function updateOnlineUsersList(users) {
    if (!elements.onlineUsersList) return;
    
    const otherUsers = users.filter(user => user.id !== currentUser.id);
    
    if (elements.onlineCount) {
        elements.onlineCount.textContent = otherUsers.length;
    }
    
    elements.onlineUsersList.innerHTML = otherUsers.length === 0
        ? '<div class="text-muted text-center p-3">No other users online</div>'
        : otherUsers.map(user => `
            <div class="online-user d-flex align-items-center p-2">
                <div class="user-avatar me-2">
                    <div class="avatar-circle" style="background-color: ${getUserColor(user.id)}">
                        ${user.username.charAt(0).toUpperCase()}
                    </div>
                </div>
                <div class="user-info">
                    <div class="username">${escapeHtml(user.username)}</div>
                    <div class="user-status">
                        <span class="status-indicator online"></span>
                        <span class="status-text">Online</span>
                    </div>
                </div>
            </div>
        `).join('');
}

function updateTypingIndicator() {
    if (!elements.typingIndicator) return;
    
    const users = Array.from(typingUsers);
    if (users.length === 0) {
        elements.typingIndicator.style.display = 'none';
        return;
    }
    
    let message;
    if (users.length === 1) {
        message = `${users[0]} is typing...`;
    } else if (users.length === 2) {
        message = `${users[0]} and ${users[1]} are typing...`;
    } else {
        message = `${users[0]} and ${users.length - 1} others are typing...`;
    }
    
    elements.typingIndicator.textContent = message;
    elements.typingIndicator.style.display = 'block';
}

// ============================================
// Event Handlers
// ============================================

function handleChatMessage(message) {
    if (!message?.content) return;
    
    displayMessage({
        sender: message.user_id === currentUser.id ? 'You' : message.username,
        content: message.content,
        messageType: message.user_id === currentUser.id ? 'message-sent' : 'message-received',
        timestamp: message.timestamp
    });
}

function handleUserJoined({ username } = {}) {
    if (!username) return;
    
    displayMessage({
        sender: 'System',
        content: `${username} has joined the chat`,
        messageType: 'system-message'
    });
    
    requestOnlineUsers();
}

function handleUserLeft({ username } = {}) {
    if (!username) return;
    
    displayMessage({
        sender: 'System',
        content: `${username} has left the chat`,
        messageType: 'system-message'
    });
    
    requestOnlineUsers();
}

function handleTypingIndicator({ username, is_typing: isTyping } = {}) {
    if (!username || username === currentUser.username) return;
    
    if (isTyping) {
        typingUsers.add(username);
    } else {
        typingUsers.delete(username);
    }
    
    updateTypingIndicator();
}

// ============================================
// API Functions
// ============================================

function requestOnlineUsers() {
    console.group('Requesting Online Users');
    
    if (!socket) {
        console.error('‚ùå Cannot request online users: WebSocket not initialized');
        console.groupEnd();
        return false;
    }

    if (socket.readyState !== WebSocket.OPEN) {
        console.error(`‚ùå Cannot request online users: WebSocket is not open (state: ${getWebSocketState(socket.readyState)})`);
        console.groupEnd();
        return false;
    }

    const request = {
        type: 'get_online_users',
        request_id: `req_${Date.now()}`,
        timestamp: new Date().toISOString()
    };

    console.log('üì° Sending online users request:', request);
    
    try {
        socket.send(JSON.stringify(request));
        console.log('‚úÖ Online users request sent successfully');
        return true;
    } catch (error) {
        console.error('‚ùå Error sending online users request:', error);
        return false;
    } finally {
        console.groupEnd();
    }
}

// ============================================
// Event Listeners
// ============================================

function setupEventListeners() {
    // Message form submission
    if (elements.messageForm) {
        elements.messageForm.addEventListener('submit', (e) => {
            e.preventDefault();
            const message = elements.messageInput?.value.trim();
            if (message) {
                sendMessage(message);
                elements.messageInput.value = '';
                sendTypingIndicator(false);
            }
        });
    }

    // Typing indicator
    if (elements.messageInput) {
        elements.messageInput.addEventListener('input', () => {
            clearTimeout(typingTimer);
            
            if (elements.messageInput.value.trim()) {
                sendTypingIndicator(true);
                typingTimer = setTimeout(() => sendTypingIndicator(false), TYPING_TIMEOUT);
            } else {
                sendTypingIndicator(false);
            }
        });
        
        elements.messageInput.addEventListener('blur', () => {
            clearTimeout(typingTimer);
            sendTypingIndicator(false);
        });
    }
    
    // Toggle sidebar on mobile
    if (elements.toggleSidebarBtn && elements.chatSidebar) {
        elements.toggleSidebarBtn.addEventListener('click', () => {
            elements.chatSidebar.classList.toggle('show');
        });
    }
    
    // Keyboard shortcuts
    document.addEventListener('keydown', (e) => {
        if (e.key === '/' && !['INPUT', 'TEXTAREA'].includes(document.activeElement.tagName)) {
            e.preventDefault();
            elements.messageInput?.focus();
        }
    });
}

// ============================================
// Test Functions
// ============================================

/**
 * Tests the WebSocket connection by sending a ping message
 * and waiting for a pong response
 */
async function testWebSocketConnection() {
    console.group('Testing WebSocket Connection');
    
    if (!socket || socket.readyState !== WebSocket.OPEN) {
        console.error('‚ùå WebSocket is not connected');
        console.groupEnd();
        return false;
    }

    const testId = `test_${Date.now()}`;
    const testMessage = {
        type: 'ping',
        test_id: testId,
        timestamp: new Date().toISOString()
    };

    console.log('Sending test ping message:', testMessage);
    
    return new Promise((resolve) => {
        // Set up a one-time message handler for the pong response
        const handlePong = (event) => {
            try {
                const message = JSON.parse(event.data);
                if (message.type === 'pong' && message.test_id === testId) {
                    console.log('‚úÖ Received pong response:', message);
                    socket.removeEventListener('message', handlePong);
                    clearTimeout(timeout);
                    resolve(true);
                }
            } catch (error) {
                console.error('Error processing test response:', error);
            }
        };

        // Set a timeout in case we don't receive a response
        const timeout = setTimeout(() => {
            console.error('‚ùå Test timed out waiting for pong response');
            socket.removeEventListener('message', handlePong);
            resolve(false);
        }, 3000);

        // Send the ping message
        try {
            socket.addEventListener('message', handlePong);
            socket.send(JSON.stringify(testMessage));
            console.log('‚úÖ Ping message sent successfully');
        } catch (error) {
            console.error('‚ùå Error sending test message:', error);
            clearTimeout(timeout);
            socket.removeEventListener('message', handlePong);
            resolve(false);
        }
    });
}

// ============================================
// Initialization
// ============================================

function initialize() {
    console.log('Initializing chat...');
    
    if (!AUTH_TOKEN) {
        console.error('No authentication token found');
        updateConnectionStatus(false, 'Please log in to use the chat');
        return;
    }
    
    setupEventListeners();
    
    // Add test button to the UI
    const testButton = document.createElement('button');
    testButton.id = 'test-connection-btn';
    testButton.textContent = 'Test Connection';
    testButton.style.position = 'fixed';
    testButton.style.bottom = '10px';
    testButton.style.right = '10px';
    testButton.style.zIndex = '1000';
    testButton.style.padding = '8px 16px';
    testButton.style.borderRadius = '4px';
    testButton.style.backgroundColor = '#4CAF50';
    testButton.style.color = 'white';
    testButton.style.border = 'none';
    testButton.style.cursor = 'pointer';
    testButton.addEventListener('click', async () => {
        testButton.disabled = true;
        testButton.textContent = 'Testing...';
        const success = await testWebSocketConnection();
        testButton.textContent = success ? '‚úÖ Test Passed' : '‚ùå Test Failed';
        setTimeout(() => {
            testButton.textContent = 'Test Connection';
            testButton.disabled = false;
        }, 2000);
    });
    document.body.appendChild(testButton);
    
    // Initialize WebSocket connection
    initWebSocket().then(async () => {
        console.log('WebSocket initialized, testing connection...');
        const success = await testWebSocketConnection();
        if (success) {
            console.log('Connection test successful, requesting online users...');
            requestOnlineUsers();
        }
    }).catch(error => {
        console.error('Failed to initialize WebSocket:', error);
        updateConnectionStatus(false, 'Connection failed. Retrying...');
    });
    
    displayMessage({
        sender: 'System',
        content: 'Welcome to the chat! Type a message to get started.',
        messageType: 'system-message'
    });
}

// Start the application when the DOM is loaded
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initialize);
} else {
    initialize();
}
